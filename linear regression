# -*- coding: utf-8 -*-
"""
Created on Tue May 15 21:58:34 2018

@author: Administrator
"""

'''
线性回归的核心是最小二乘：有两种方法实现
１，（Ｘ-Ｙ)^2 =误差　　把所有数据特征值的误差相加，然后对单个特征值求偏导数，最后得出来的是这个误差最小值
２，Ｘ=ＩＮＶ(Ａ.Ｔ　Ａ)Ａ.ＴＢ，通过正规方程组来求解

'''


##################this is my first AI learn#######################
#-*- coding: utf-8 -*-
import matplotlib.pyplot as plt#显示２Ｄ画图
import os
import numpy as np
from numpy import poly1d
#coding: utf-8
add=("D://traningset//houses.txt")


###########文本文件读取后，进行处理成我们想要的数据##################
def filepro(filename):
    """ 读取数据
        filename 文件名
      返回，Ｘ１,Ｘ２特征向量Ｘ,Ｙ为输出结果
        X 训练样本集矩阵
        y 标签集矩阵
    """
#open(filename).readline()=打开文件，整行的数据
#numfeat是3列数据中减去结果y那列得到的结果
#    lineArr = []
    numFeat = len(open(filename).readline().split('\t')) - 1
    X = []
    y = []
#    print(open(filename).readline() )
    file = open(filename)
    for line in file.readlines():#列出每一行
        lineArr = []#必须要重新来付值
        
        curLine = line.strip().split('\t')#去掉数据中　头和尾的空格
#        print(curLine)
        for i in range(numFeat):#
            lineArr.append(float(curLine[i]))#每个数组里面去掉最后一个
        
        X.append(lineArr)
        y.append(float(curLine[-1]))
#    print('x is value is:',np.mat(X))
##    print('y is value is:',np.mat(y).T)    
    return np.mat(X), np.mat(y).T
#把Ｘ转换成矩阵，把Ｙ转置，变成向量Ｙ

##########################线性回归###########################
def lms(maxLoop, epsilon,rate,x,y):
#    global theta,row,errors,thetas
    row,col=x.shape
    aaa=0
    alldone=0
    errors=[]
    bbbb=epsilon
    theta=np.zeros((col+1,1))#把theta设置为一列，行数取决于Ｘ的Ｍ列
    thetas={}
    a=np.ones(row).reshape(row,1)
    x=np.column_stack((a,x))
#    y=y/100
    
    x471=np.ones(row).reshape(row,-1)
#    print(a)
#    np.colum_stack((a,b))
    for j in range(col+1):
        thetas[j]=[theta[j,0]]
    while(maxLoop):
        maxLoop=maxLoop-1
        if(alldone):
            break
#        print('this is thetas :',theta)
#        print('this is x:',x)
#        print('this isy :',y)
##        print('this is theta:',theta)
##################正规方程组可以直接得到结果########################
#        theta=np.linalg.inv(x.T*x)*x.T*y
#        print('this is norm :',theta)
#        print('col',col)
        for i in range(col+1):
            x1=x[:,i]#取Ｘ的3列中的一列
            y1=y#取Ｙ，Ｙ本来就是４８行２列中的一列
            theta=theta#这个数是3行*一列
#            print('x1.shape',x1.shape)
#            print('y1.shape',y1.shape)
#            print('theta.shape',theta.shape)
#            
#            print('x.shape',x.shape)
#            print('y.shape',y.shape)
                  
            
            
            
            if(i==0):
                deriv=rate*((y1-x*theta).T*x471)/row#对Ｊtheta求导数
#                pass
            else:
                deriv=rate*(((y1-x*theta).T*x1)/row)#对Ｊtheta求导数
#                pass
#            print('deriv',deriv.shape)
#            print('theta[i,:]',theta[i,:])
#            deriv=rate*((y1-x*theta).T*x1)/row#对Ｊtheta求导数
#            deriv=rate*((y1-x*theta).T*x1)/row#对Ｊtheta求导数
            theta[i,:]=theta[i,:]+deriv #把求得的theta值不断的更新
            thetas[i].append(theta[i,0])
#            print('x471',x471)    
#            print('this is thetas :',thetas)
#            print('this is h deriv :',h(theta,x1))
#            print('this is h deriv2 :',rate*((y1-x*theta).T*x1)/(2*row))
#            print('this is h y1-x*theta :',x*theta)
#            print('this is ((y1-x*theta).T*x1) :',rate*((y1-x*theta).T*x1)/row)
#            print('this is theta[i,:] :',theta[i,:])
#            print('this is error1 :', (y-x*theta).T*(y-x*theta))
#            print('this is theta :', theta)
        error=(y-x*theta).T*(y-x*theta)/(2*row)#这个ＯＫ,
#        abc=error(0)
        errors.append(error[0,0]/100000)#o
#        print('this is errors :',errors)
#        print('error:',np.sum(np.power((y-x*theta),2)) /(2*row) )#这个ＯＫ
#        errors=[-1]=error[0,0]
#        if(np.max(thetas[1])>epsilon):
#            alldone=1
#        print('thetas:',thetas)
    return  theta, thetas,x



number1=5
#number1=int(input("enter number=:"))


x,y=filepro(add)#文件处理，把矩阵处理成自己想要的   
row,col=x.shape
#a=np.ones(row).reshape(row,1)
#x=np.column_stack((a,x))
#a,b=lms(55,22,0.0000000000000001,x,y)

#t1,t0,x12=lms(400,100,0.00000000001,x,y)
#t1,t0,x12=lms(400,100,0.0000000001,x,y)
#t1,t0,x12=lms(40,100,0.000000001,x,y)
#t1,t0,x12=lms(88,0.2,0.00000001,x,y)
t1,t0,x12=lms(number1,0.19,0.0000001,x,y)#
#t1,t0,x12=lms(1,0.2,0.000001,x,y)
#t1,t0,x12=lms(40,100,0.00001,x,y)
#t1,t0,x12=lms(4,100,0.0001,x,y)
#t1,t0,x12=lms(40,100,0.001,x,y)
#t1,t0,x12=lms(4,100,0.1,x,y)

##############################################################
#xx0=x[:,0].reshape(-1,1).T
#xx1=x[:,1].reshape(-1,1).T
#xx2=x[:,1].reshape(-1,1).T
#cc,dd=xx0.shape
#yyy=(x12*t1).reshape(-1,1)#yy=最终猜的价格
#print('theta',t1)
#print('thetas',t0)
#ddd=np.arange(0,dd,1)
#plt.scatter(ddd,x12*t1,marker="o",color='m',label='12',s=54) #Ｙ原始数据
#plt.plot(ddd,yyy,'b--')



###########################线性拟合图###################################
xx0=x[:,0].reshape(-1,1).T
xx1=x[:,1].reshape(-1,1).T
row1,col1=x.shape
jtheta=[]
thetarow1=t1[1,:]
thetarow2=t1[2,:]
#print('44',thetarow1,thetarow2)

#xrow=x[i,:]#2*1
#print('rr',xrow[:,0])


for i in range(row1):
#    pass
    xrow=x[i,:]#2*1
#    print(xrow())
    jtheta.append((xrow[:,0]*thetarow1+xrow[:,1]*thetarow2)[0,0])

#print('jtheta',jtheta)
jtheta=np.array(jtheta).reshape(-1,1).T

#cc,dd=x.shape
#yyy=(x12*t1).reshape(-1,1)#yy=最终猜的价格
print('theta',t1)
print('xx0',xx0.shape)
print('jtheta',jtheta.shape)
jtheta=jtheta

plt.scatter(xx0.tolist()[0],y.T.tolist()[0],marker="o",color='g',label='12',s=31) #Ｙ原始数据
#plt.scatter(xx0.tolist(),jtheta.tolist(),marker="o",color='r',label='12',s=11) #Ｙ原始数据
plt.plot(xx1.tolist()[0],jtheta.tolist()[0],'r-')#拟合THETA后的数据
plt.title('this is linear regeression dot pic')
plt.xlabel('house feature ')
plt.ylabel('house price')
plt.show()
